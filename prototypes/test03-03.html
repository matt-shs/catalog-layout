<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Cards PDF Export Row-Based with Formatting and Random Images</title>
<style>
  body { font-family: Arial; background: #fff; display: flex; justify-content: center; margin: 20px; }
  .page-container { display: flex; flex-direction: column; align-items: center; }
  .controls { margin-bottom: 20px; display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
  input { width: 80px; padding: 4px; font-size: 14px; }
  button { padding: 6px 12px; font-size: 14px; cursor: pointer; }
  .cards-container { display: flex; flex-wrap: wrap; gap: 10px; justify-content: flex-start; max-width: 100%; }
  .card { background: #fff; border-radius: 0; padding: 10px; box-sizing: border-box; display: flex; flex-direction: column; }
  .card img { width: 100%; height: auto; margin-bottom: 6px; object-fit: cover; }
  .meta { margin: 0 0 2px 0; font-size: 12px; }
  .meta__part { font-weight: bold; margin-right: 5px; }
</style>
</head>
<body>
<div class="page-container">
  <div class="controls">
    <label for="cardsPerRow">Cards per row: </label>
    <input type="number" id="cardsPerRow" min="1" max="12" value="5">
    <button id="exportPdf">Export PDF</button>
  </div>
  <div class="cards-container" id="cardsContainer"></div>
</div>

<script src="https://cdn.jsdelivr.net/npm/pdf-lib/dist/pdf-lib.min.js"></script>
<script>
const cardsContainer = document.getElementById('cardsContainer');
let cards = [];
const inputCardsPerRow = document.getElementById('cardsPerRow');

// Array of images to randomly pick from
const cardImages = ['PWS_4.png']; // Add more filenames here

// Generate random cards
function createRandomCards(count) {
  cardsContainer.innerHTML = '';
  cards = [];
  const relatedOptions = [1,3,4,8];

  for (let i = 0; i < count; i++) {
    const card = document.createElement('div');
    card.className = 'card';

    // Pick a random image from the array
    const img = document.createElement('img');
    const randomImage = cardImages[Math.floor(Math.random() * cardImages.length)];
    img.src = randomImage;
    img.onerror = () => { img.style.display = 'none'; };
    card.appendChild(img);

    const mainPart = document.createElement('p');
    mainPart.className = 'meta';
    mainPart.innerHTML = `<span class="meta__part">PN-${Math.floor(Math.random()*100000)}</span>5x3 AL`;
    card.appendChild(mainPart);

    const relatedCount = relatedOptions[Math.floor(Math.random()*4)];
    for (let j=0; j<relatedCount; j++){
      const p = document.createElement('p');
      p.className = 'meta';
      p.textContent = 'PN-'+Math.floor(Math.random()*100000);
      card.appendChild(p);
    }

    cardsContainer.appendChild(card);
    cards.push(card);
  }
}

// Update on-screen layout dynamically
function updateCardLayout() {
  const cardsPerRow = Math.min(Math.max(parseInt(inputCardsPerRow.value)||1,1),12);
  const gap = 10;
  const containerWidth = Math.min(window.innerWidth-40, 1200);
  const cardWidth = `calc(${100 / cardsPerRow}% - ${(gap * (cardsPerRow - 1)) / cardsPerRow}px)`;
  cardsContainer.style.width = containerWidth + 'px';
  cards.forEach(card => card.style.width = cardWidth);
}

inputCardsPerRow.addEventListener('input', updateCardLayout);
window.addEventListener('resize', updateCardLayout);

createRandomCards(50);
updateCardLayout();

// PDF export: row-based layout with formatting, spacing, and random images
document.getElementById('exportPdf').addEventListener('click', async () => {
  const { PDFDocument, StandardFonts, rgb } = PDFLib;
  const pdfDoc = await PDFDocument.create();
  const pageWidth = 595;
  const pageHeight = 842;
  const margin = 20;
  const gap = 10;
  const lineHeight = 12;
  const padding = 6; // space between image and text

  const fontRegular = await pdfDoc.embedFont(StandardFonts.Helvetica);
  const fontBold = await pdfDoc.embedFont(StandardFonts.HelveticaBold);

  const cardsPerRow = Math.min(Math.max(parseInt(inputCardsPerRow.value)||1,1),12);
  const cardWidthPdf = (pageWidth - margin*2 - gap*(cardsPerRow-1)) / cardsPerRow;

  // Preload images
  const imageBuffers = await Promise.all(cards.map(card => {
    const imgElem = card.querySelector('img');
    if(imgElem && imgElem.complete && imgElem.naturalWidth!==0){
      return fetch(imgElem.src).then(r=>r.arrayBuffer());
    } else return null;
  }));

  let page = pdfDoc.addPage([pageWidth, pageHeight]);
  let yOffset = pageHeight - margin;

  // Chunk cards into rows
  for(let i=0; i<cards.length; i+=cardsPerRow){
    const rowCards = cards.slice(i, i+cardsPerRow);

    // Calculate max row height
    const rowHeight = Math.max(...rowCards.map(c => {
      const textLines = c.querySelectorAll('.meta').length;
      return cardWidthPdf + padding + textLines*lineHeight + 6; // extra bottom padding
    }));

    // New page if row doesn't fit
    if(yOffset - rowHeight < margin){
      page = pdfDoc.addPage([pageWidth, pageHeight]);
      yOffset = pageHeight - margin;
    }

    // Draw each card in row
    let xOffset = margin;
    for(let j=0; j<rowCards.length; j++){
      const card = rowCards[j];
      const idx = cards.indexOf(card);
      const imgBuffer = imageBuffers[idx];

      // Draw image
      const imgHeightPdf = cardWidthPdf; // square image
      if(imgBuffer){
        const image = await pdfDoc.embedPng(imgBuffer);
        
        page.drawImage(image, { x: xOffset, y: yOffset - imgHeightPdf - padding, width: cardWidthPdf, height: imgHeightPdf });
      } else {
        page.drawRectangle({ x: xOffset, y: yOffset - imgHeightPdf - padding, width: cardWidthPdf, height: imgHeightPdf, color: rgb(0.8,0.8,0.8) });
        page.drawText('No Image', { x: xOffset+5, y: yOffset - imgHeightPdf/2, size: 12, color: rgb(0.3,0.3,0.3) });
      }

      // Draw text below image with formatting
      let textY = yOffset - imgHeightPdf - padding - lineHeight;
      const paragraphs = Array.from(card.querySelectorAll('.meta'));
      for(const p of paragraphs){
        let xText = xOffset + 2;
        const spans = p.querySelectorAll('.meta__part');

        if(spans.length > 0){
          spans.forEach(span => {
            page.drawText(span.textContent, { x: xText, y: textY, size: 10, font: fontBold, color: rgb(0,0,0) });
            xText += fontBold.widthOfTextAtSize(span.textContent, 10);
          });
          const remaining = p.textContent.replace(Array.from(spans).map(s=>s.textContent).join(''), '');
          if(remaining.trim() !== ''){
            page.drawText(remaining, { x: xText, y: textY, size: 10, font: fontRegular, color: rgb(0,0,0) });
          }
        } else {
          page.drawText(p.textContent, { x: xText, y: textY, size: 10, font: fontRegular, color: rgb(0,0,0) });
        }

        textY -= lineHeight;
      }

      xOffset += cardWidthPdf + gap;
    }

    // Move down for next row
    yOffset -= rowHeight + gap;
  }

  const pdfBytes = await pdfDoc.save();
  const blob = new Blob([pdfBytes], { type: 'application/pdf' });
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = 'cards.pdf';
  link.click();
});
</script>
</body>
</html>
